name: ğŸš€ Keep SplitEase Backend Alive

on:
  schedule:
    # Run every 59 minutes to prevent Render cold starts
    - cron: '*/59 * * * *'
    # Run daily health check at 6 AM UTC
    - cron: '0 6 * * *'
  
  # Allow manual triggering
  workflow_dispatch:
    inputs:
      ping_type:
        description: 'Type of ping to perform'
        required: true
        default: 'backend_ping'
        type: choice
        options:
          - backend_ping
          - health_check
          - emergency_revival

# Set environment variables
env:
  BACKEND_URL: ${{ secrets.BACKEND_URL }}  # Your Render backend URL

jobs:
  # Job 1: Keep Render Backend Alive (Prevent Cold Starts)
  keep-backend-alive:
    name: ğŸ”¥ Keep Backend Warm
    runs-on: ubuntu-latest
    
    # Run for scheduled events and manual backend ping triggers
    if: |
      github.event_name == 'schedule' || 
      (github.event_name == 'workflow_dispatch' && 
       github.event.inputs.ping_type == 'backend_ping')
    
    steps:
      - name: ğŸ“ Ping Backend Server
        run: |
          echo "ğŸš€ Pinging backend to keep it alive..."
          
          # Try multiple endpoints that should exist in your backend
          endpoints=(
            "/"
            "/api/stats"
          )
          
          success_count=0
          total_endpoints=${#endpoints[@]}
          
          for endpoint in "${endpoints[@]}"; do
            echo "ğŸ“¡ Pinging: $BACKEND_URL$endpoint"
            
            response=$(curl -s -o /dev/null -w "%{http_code}" \
              --max-time 30 \
              --retry 3 \
              --retry-delay 5 \
              "$BACKEND_URL$endpoint" || echo "000")
            
            if [[ "$response" =~ ^[2-4][0-9][0-9]$ ]]; then
              echo "âœ… Success: $endpoint responded with HTTP $response"
              ((success_count++))
            else
              echo "âš ï¸ Warning: $endpoint responded with HTTP $response"
            fi
            
            # Small delay between requests
            sleep 2
          done
          
          echo "ğŸ‰ Backend ping completed!"
          echo "ğŸ“Š Success rate: $success_count/$total_endpoints endpoints responded successfully"
          
          # If at least one endpoint succeeds, consider it successful
          if [ $success_count -gt 0 ]; then
            echo "âœ… Backend is alive and responding!"
          else
            echo "âŒ All endpoints failed - backend may be down"
            exit 1
          fi

      - name: ğŸ“Š Log Backend Status
        run: |
          echo "ğŸ“ˆ Backend Keep-Alive Summary:"
          echo "â° Timestamp: $(date -u)"
          echo "ğŸŒ Backend URL: $BACKEND_URL"
          echo "ğŸ”„ Ping Type: Scheduled Backend Keep-Alive"
          echo "â­ï¸ Next ping in 10 minutes"

  # Job 2: Daily Health Check
  daily-health-check:
    name: ğŸ¥ Daily Health Check
    runs-on: ubuntu-latest
    
    # Run on daily schedule and manual health check triggers
    if: |
      (github.event_name == 'schedule' && contains(github.event.schedule, '0 6')) || 
      (github.event_name == 'workflow_dispatch' && github.event.inputs.ping_type == 'health_check')
    
    steps:
      - name: ğŸ¥ Comprehensive Backend Health Check
        run: |
          echo "ğŸ¥ Running comprehensive health check..."
          
          # Health check endpoints that should exist
          health_endpoints=(
            "/"
            "/api/stats"
          )
          
          failed_checks=0
          total_checks=0
          
          for endpoint in "${health_endpoints[@]}"; do
            ((total_checks++))
            echo "ğŸ” Checking: $BACKEND_URL$endpoint"
            
            start_time=$(date +%s)
            response=$(curl -s -w "%{http_code}" \
              --max-time 30 \
              "$BACKEND_URL$endpoint" || echo "000")
            end_time=$(date +%s)
            
            response_time=$((end_time - start_time))
            
            if [[ "$response" =~ ^[2-4][0-9][0-9]$ ]]; then
              echo "âœ… PASS: $endpoint (${response_time}s, HTTP $response)"
            else
              echo "âŒ FAIL: $endpoint (${response_time}s, HTTP $response)"
              ((failed_checks++))
            fi
          done
          
          echo ""
          echo "ğŸ“Š Health Check Summary:"
          echo "âœ… Passed: $((total_checks - failed_checks))/$total_checks"
          echo "âŒ Failed: $failed_checks/$total_checks"
          
          if [ $failed_checks -eq $total_checks ]; then
            echo "ğŸš¨ All health checks failed - backend appears to be down!"
            exit 1
          elif [ $failed_checks -gt 0 ]; then
            echo "âš ï¸ Some health checks failed but backend is partially responsive"
          else
            echo "ğŸ‰ All health checks passed!"
          fi

      - name: ğŸ“ˆ Performance Metrics
        run: |
          echo "ğŸ“ˆ Collecting performance metrics..."
          
          # Test response times for main endpoint
          response_times=()
          
          for i in {1..3}; do
            start_time=$(date +%s%3N)
            response=$(curl -s -o /dev/null -w "%{http_code}" "$BACKEND_URL/api/stats" || echo "000")
            end_time=$(date +%s%3N)
            response_time=$((end_time - start_time))
            
            if [[ "$response" =~ ^[2-4][0-9][0-9]$ ]]; then
              echo "ğŸ• Response time (attempt $i): ${response_time}ms - HTTP $response"
              response_times+=($response_time)
            else
              echo "âŒ Failed response (attempt $i): HTTP $response"
            fi
            
            sleep 1
          done
          
          # Calculate average response time if we have successful responses
          if [ ${#response_times[@]} -gt 0 ]; then
            total=0
            for time in "${response_times[@]}"; do
              total=$((total + time))
            done
            average=$((total / ${#response_times[@]}))
            echo "ğŸ“Š Average response time: ${average}ms"
          fi

      - name: ğŸ“§ Health Report Summary
        run: |
          echo "ğŸ“‹ Daily Health Report - $(date -u)"
          echo "ğŸŒ Backend URL: $BACKEND_URL"
          echo "ğŸ”„ Keep-alive status: Active"
          echo "â° Next check: $(date -u -d '+1 day')"
          echo "ğŸš€ System status: Operational"

  # Job 3: Emergency Revival (Manual only)
  emergency-revival:
    name: ğŸš¨ Emergency Service Revival
    runs-on: ubuntu-latest
    
    # Only run on manual trigger with emergency option
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.ping_type == 'emergency_revival'
    
    steps:
      - name: ğŸš¨ Emergency Revival Protocol
        run: |
          echo "ğŸš¨ Executing emergency revival protocol..."
          
          revival_attempts=0
          max_attempts=5
          success=false
          
          while [ $revival_attempts -lt $max_attempts ] && [ "$success" = false ]; do
            ((revival_attempts++))
            echo "ğŸ”„ Revival attempt $revival_attempts/$max_attempts..."
            
            # Try main endpoint first
            response=$(curl -s -o /dev/null -w "%{http_code}" \
              --max-time 60 \
              --retry 3 \
              --retry-delay 10 \
              "$BACKEND_URL/" || echo "000")
            
            if [[ "$response" =~ ^[2-4][0-9][0-9]$ ]]; then
              echo "âœ… Revival successful! Backend responded with HTTP $response"
              success=true
            else
              echo "âŒ Attempt $revival_attempts failed (HTTP $response)"
              if [ $revival_attempts -lt $max_attempts ]; then
                echo "â³ Waiting 30 seconds before next attempt..."
                sleep 30
              fi
            fi
          done
          
          if [ "$success" = true ]; then
            echo "ğŸ‰ Emergency revival completed successfully!"
          else
            echo "ğŸš¨ Emergency revival failed after $max_attempts attempts"
            exit 1
          fi
