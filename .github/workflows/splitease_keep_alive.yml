name: ğŸš€ Keep SplitEase Backend & Redis Alive

on:
  schedule:
    # Run every 59 minutes to prevent Render cold starts
    - cron: '*/59 * * * *'
    # Run every hour for Redis keep-alive (additional protection)
    - cron: '55 * * * *'
    # Run daily health check at 6 AM UTC
    - cron: '0 6 * * *'
  
  # Allow manual triggering
  workflow_dispatch:
    inputs:
      ping_type:
        description: 'Type of ping to perform'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - backend_only
          - redis_only
          - health_check

# Set environment variables
env:
  BACKEND_URL: ${{ secrets.BACKEND_URL }}  # Your Render backend URL
  FRONTEND_URL: ${{ secrets.FRONTEND_URL }} # Your frontend URL (optional)

jobs:
  # Job 1: Keep Render Backend Alive (Prevent Cold Starts)
  keep-backend-alive:
    name: ğŸ”¥ Keep Backend Warm
    runs-on: ubuntu-latest
    
    # Run for all scheduled events and manual triggers
    if: |
      github.event_name == 'schedule' || 
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.ping_type == 'all' || github.event.inputs.ping_type == 'backend_only'))
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ“ Ping Backend Server
        run: |
          echo "ğŸš€ Pinging backend to keep it alive..."
          
          # Try multiple endpoints to ensure comprehensive wake-up
          endpoints=(
            "/api/stats"
            "/api/auth/status"
            "/api/profile/health"
          )
          
          for endpoint in "${endpoints[@]}"; do
            echo "ğŸ“¡ Pinging: $BACKEND_URL$endpoint"
            
            response=$(curl -s -o /dev/null -w "%{http_code}" \
              --max-time 30 \
              --retry 3 \
              --retry-delay 5 \
              "$BACKEND_URL$endpoint" || echo "000")
            
            if [[ "$response" =~ ^[2-4][0-9][0-9]$ ]]; then
              echo "âœ… Success: $endpoint responded with HTTP $response"
            else
              echo "âš ï¸ Warning: $endpoint responded with HTTP $response"
            fi
            
            # Small delay between requests
            sleep 2
          done
          
          echo "ğŸ‰ Backend ping completed!"

      - name: ğŸ“Š Log Backend Status
        run: |
          echo "ğŸ“ˆ Backend Keep-Alive Summary:"
          echo "â° Timestamp: $(date -u)"
          echo "ğŸŒ Backend URL: $BACKEND_URL"
          echo "ğŸ”„ Ping Type: Scheduled Backend Keep-Alive"

  # Job 2: Keep Redis Alive (Upstash Protection)
  keep-redis-alive:
    name: ğŸ”´ Keep Redis Active
    runs-on: ubuntu-latest
    
    # Run on hourly schedule and manual triggers
    if: |
      (github.event_name == 'schedule' && contains(github.event.schedule, '0 ')) || 
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.ping_type == 'all' || github.event.inputs.ping_type == 'redis_only'))
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ”´ Interact with Redis via Backend
        run: |
          echo "ğŸ”´ Triggering Redis activity through backend..."
          
          # Use endpoints that interact with Redis
          redis_endpoints=(
            "/api/stats"
            "/api/transactions/recent"
          )
          
          for endpoint in "${redis_endpoints[@]}"; do
            echo "ğŸ”´ Redis interaction via: $BACKEND_URL$endpoint"
            
            response=$(curl -s -w "%{http_code}" \
              --max-time 30 \
              --retry 2 \
              --retry-delay 3 \
              "$BACKEND_URL$endpoint" || echo "000")
            
            echo "ğŸ“Š Redis endpoint response: $response"
            sleep 5
          done

      - name: ğŸ”„ Force Redis Keep-Alive via Backend
        run: |
          echo "ğŸ”„ Sending dedicated keep-alive signal..."
          
          # This will trigger the Redis keep-alive mechanism in your backend
          response=$(curl -s -w "%{http_code}" \
            --max-time 45 \
            --retry 2 \
            -X POST \
            -H "Content-Type: application/json" \
            -d '{"action": "keepalive", "source": "github_actions"}' \
            "$BACKEND_URL/api/health/keepalive" || echo "000")
          
          echo "ğŸ’– Keep-alive response: $response"

      - name: ğŸ“Š Log Redis Activity
        run: |
          echo "ğŸ”´ Redis Keep-Alive Summary:"
          echo "â° Timestamp: $(date -u)"
          echo "ğŸ”„ Activity Type: Redis Interaction via Backend"
          echo "ğŸš€ Next Redis ping in 1 hour"

  # Job 3: Comprehensive Health Check (Daily)
  daily-health-check:
    name: ğŸ¥ Daily Health Check
    runs-on: ubuntu-latest
    
    # Run on daily schedule and manual health check triggers
    if: |
      (github.event_name == 'schedule' && contains(github.event.schedule, '0 6')) || 
      (github.event_name == 'workflow_dispatch' && github.event.inputs.ping_type == 'health_check')
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ¥ Comprehensive Backend Health Check
        run: |
          echo "ğŸ¥ Running comprehensive health check..."
          
          # Health check endpoints
          health_endpoints=(
            "/api/stats"
            "/api/health"
            "/api/auth/status"
          )
          
          failed_checks=0
          total_checks=0
          
          for endpoint in "${health_endpoints[@]}"; do
            ((total_checks++))
            echo "ğŸ” Checking: $BACKEND_URL$endpoint"
            
            start_time=$(date +%s)
            response=$(curl -s -w "%{http_code}" \
              --max-time 30 \
              "$BACKEND_URL$endpoint" || echo "000")
            end_time=$(date +%s)
            
            response_time=$((end_time - start_time))
            
            if [[ "$response" =~ ^[2][0-9][0-9]$ ]]; then
              echo "âœ… PASS: $endpoint (${response_time}s, HTTP $response)"
            else
              echo "âŒ FAIL: $endpoint (${response_time}s, HTTP $response)"
              ((failed_checks++))
            fi
          done
          
          echo ""
          echo "ğŸ“Š Health Check Summary:"
          echo "âœ… Passed: $((total_checks - failed_checks))/$total_checks"
          echo "âŒ Failed: $failed_checks/$total_checks"
          
          if [ $failed_checks -gt 0 ]; then
            echo "âš ï¸ Some health checks failed!"
            exit 1
          else
            echo "ğŸ‰ All health checks passed!"
          fi

      - name: ğŸ”´ Redis Connection Test
        run: |
          echo "ğŸ”´ Testing Redis connectivity..."
          
          # Test Redis via backend endpoint that uses cache
          response=$(curl -s -w "%{http_code}" \
            --max-time 30 \
            "$BACKEND_URL/api/stats")
          
          if [[ "$response" =~ ^[2][0-9][0-9]$ ]]; then
            echo "âœ… Redis connectivity test PASSED"
          else
            echo "âŒ Redis connectivity test FAILED (HTTP $response)"
          fi

      - name: ğŸ“ˆ Performance Metrics
        run: |
          echo "ğŸ“ˆ Collecting performance metrics..."
          
          # Test response times for key endpoints
          for i in {1..3}; do
            start_time=$(date +%s%3N)
            curl -s -o /dev/null "$BACKEND_URL/api/stats"
            end_time=$(date +%s%3N)
            response_time=$((end_time - start_time))
            echo "ğŸ• Response time (attempt $i): ${response_time}ms"
          done

      - name: ğŸ“§ Health Report Summary
        run: |
          echo "ğŸ“‹ Daily Health Report - $(date -u)"
          echo "ğŸŒ Backend URL: $BACKEND_URL"
          echo "ğŸ”„ Keep-alive status: Active"
          echo "ğŸ”´ Redis status: Active"
          echo "â° Next check: $(date -u -d '+1 day')"
          echo "ğŸš€ System status: Operational"

  # Job 4: Emergency Revival (if needed)
  emergency-revival:
    name: ğŸš¨ Emergency Service Revival
    runs-on: ubuntu-latest
    
    # Only run on manual trigger with emergency option
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.ping_type == 'emergency'
    
    steps:
      - name: ğŸš¨ Emergency Revival Protocol
        run: |
          echo "ğŸš¨ Executing emergency revival protocol..."
          
          # Aggressive ping strategy
          for i in {1..10}; do
            echo "ğŸ”„ Revival attempt $i/10..."
            
            curl -s -o /dev/null \
              --max-time 60 \
              --retry 5 \
              --retry-delay 10 \
              "$BACKEND_URL/api/stats" || true
            
            sleep 30
          done
          
          echo "ğŸ¯ Emergency revival completed!"
